Copyright (c) 2013 Robert Markwick
See the file license.txt for copying permission

This document explains how to write XPINS scripts.
XPINS stands for eXtensible Program Instruction Notation/Script

Each XPINS file has the following components:
-Version Compatibility Statements
-Function Declaration Block
-Code Block

XPINS files can also have comments. XPINS supports both Single and Multiline Comments.
Single line comments: //...
Multiline comments: /*...*/

VERSION COMPATIBILITY STATEMENTS:
The first part of every XPINS file are two version compatibility statements. The first version compatibility statement states which version of the XPINS compiler the script is designed for, and the second one states which version of the XPINS parser the script is desgined for. The Compiler statement is always the first line of an XPINS file, and the Parser compabitiblity statement is the second. A set of Compatibility statements would look like this:
@COMPILER[0.3]
@PARSER[0.6]
Only the first two components of the version numbers are used for compatibility statements, even though the version numbers for the compiler and the parser have three components. This is because the third number is used for bug fixes. In order to be compatible with a certain verison of the compiler or parser, the script's Major version number must match that of the software and the Minor version number must be less than or equal to that of the software. For example, a script that states a compiler version number of 1.2 will be compatible with all versions of the compiler from 1.2.0 until 2.0.0.

FUNCTION BLOCKS:
The second part of every XPINS file is a function block. XPINS is designed to interact with your code. In order to do this, you must write additional functions in the parser to interact with your code. In order to call these functions within your XPINS scripts, you must declare them so that XPINS can compile your code properly. A simple function block would look like this:
@FUNC
INT MAGIC_NUMBER(FLOAT,BOOL);
@END
A function block starts with @FUNC and ends with @END, each of these getting their own line. Between the two are all of the function declarartions, with one line per function declaration. A function declaration starts with its return type.  Starting with XPINS Parser 0.6, the return type is required, and requires compiler 0.3 or later. The name you write in the function blockis the name you use to call your function in code. If you spell it incorrectly, your script will not execute properly. After the name of your function come the paramaters. Paramaters follow the format of (...). The parameters are currently of no meaning to the compiler, so as long as the parentheses are present you can leave them out. For this reason no two functions can have the same name (no overloading). The function block below is equivalnt to the one above:
@FUNC
INT MAGIC_NUMBER()
@END
In XPINS, semicolons are optional and removed at compile time. The reason for this is that removing the semicolons does help slightly with both size and performance, but since the parser is written in C++, most developers using XPINS would be comfortable using semicolons.



CODE BLOCKS:
The final and most important part of an XPINS file is the code block. This is where you actually tell your code what do. A code block starts with @CODE and ends with @END. Like the function block, each of these gets its own line. Lets look at a sample code block
@CODE
INT $MYVAR2=#MAGIC_NUMBER(^0.2,^T);
BOOL $COND=X_ILESS($MYVAR2,^90);
@WHILE[$COND]{
$MYVAR2=X_IADD($MYVAR2,^10);
$COND=X_ILESS($MYVAR2,^90);
}
*MYPLAYER $AIPLAYER=#AI_PLAYER_FUNC();
#SET_FIRE_ANGLE($AIPLAYER,$MYVAR2);
@END
The first thing this script does is define a few variables. The format for declaring a variable is: TYPE $NAME=VALUE;
There are five types in XPINS: BOOL, INT, and FLOAT all correspond directly to their C++ cousins, VEC, which represents a Vector object that allows you to perform vector (Math/Science vector, not C++ vector) arithmetic without needing to write custom code, MAT, which is a Matrix of any size, and the Generic pointer type, declared as *____. The Generic Pointer Type stores a pointer to any C++ object.
When you declare a variable, you can assign it one of three things: a constant (BOOL/INT/FLOAT/VEC/MAT only), a copy of another variable, or the return value of a function (more on functions later). Constants are all preceeded by '^'. BOOLs can be assigned values of ^T or ^F. INTs and FLOATs can be assigned ^X, where X is any number permitted by that type (i.e. ^1.2 could not be assigned to an INT variable) VEC constants take the form ^<X,Y,Z>, ^P<R,THETA,Z>, or ^S<RHO,THETA<PHI>. Assigning a new value to a variable works the same way as declaring the variable, except that you don't specify the variable type (i.e. $NAME=VALUE;)
In the sample script, once we assign two constants to variables, we create a third variable, and assign to it the return value of the MAGIC_NUMBER function shown in the function block. Calling a user defined function looks like this: #FUNCTION_NAME($Var1,$Var2,...);. You as the developer get to decide how many parameters need to be passed to the function. To pass a constant as a parameter, just pass ^0.4 instead of $Var. You can also pass expression and function results as parameters. Calling any user function is indicated by a '#'. Functions do not need to have a return type. a common example is near the end of your script when you set some custom value on some object.
After Declaring a few more constants, we declare a BOOL that is assigned the return value of a built in function. Instead of being preceeded by a '#', Built in functions follow the format X_NAME(...). There are a variet of built in functions, ranging from boolean logic and Number comparison to trigonometry and Vector arithmetic. There is a list of built in functions in another document.
The BOOL we just declared is used as the condition for a while loop. while loops take the format @WHILE[$CONDITION]{...} The condition is a BOOL variable usually set just before and at the end of each iteration of a loop. If the condition is false, the loop will be skipped, and the condition is checked again once you reach the end of the loop. It will keep running until the condition evaluates to false.
While not present in this example, you can also use an If statement. If statements take the form of @IF[$CONDITION]{...}@ELSE{...} (@ELSE{...} is optional). If the condition is true, it the code inside the IF block is executed. If the ELSE block is included, it will only execute if the IF block did not.
After the while loop, we declare a genaric pointer variable. In this case, it most likely points to a struct of type MYPlAYER. We assign it to the return value of the AI_PLAYER_FUNC function (Lets assume that we declared this in our function block). We then pass this as the first argument to an object that sets the fire angle of this AI Player. We finish the script with an @END statement.
Using XPINS, you can script almost anything you can do in C/C++.


EXPRESSIONS:
In C++, there are expressions and operators that make it very easy to perform calculations. In XPINS, there are functions for addition, subtraction, etc, but those take a lot of time to write (and also use more memory). XPINS has expressions that allow mathematical calculations to performded easier. Here is a sample expression:
?B($Var1<$Var2)?
An expression always starts and ends with a '?'. At the beginning of the expression is the return type: B, I,  F, or V (there is no support for  Pointer expressions). After the type is a pair of parentheses containing the input and operator. The inputs can be constants, variables, or even other expressions. The operator goes before the last input. Valid operators at this point in time are listed below. The format for this list is: <op> : <Use> (<Return types>):(<1st Input types>),(<2nd Input types>),...
	+  : Addition (I,F):(I,F),(I,F)
	+  :Vector Addition (V):(V),(V)
	+  :Matrix Addition (M):(M),(M)
	-  :Subtraction (I,F):(I,F),(I,F)
	-  :Vector Subtraction (V):(V),(V)
	-  :Matrix Subtraction (M):(M),(M)
	*  : Multiplication (I,F):(I,F),(I,F)
	*  : Vector-Scalar Multiplication (V):(V),(I,F)
	*  : Vector Dot Product (F):(V),(V)
	*  : Vector Cross Product (V):(V),(V)
	*  : Matrix-Scalar Multiplication (M):(M),(I,F)
	*  : Matrix-Vector Multiplication (V):(M),(V)
	*  : Matrix-Matrix Multiplication (M):(M),(M)
	/  : Division (I,F):(I,F),(I,F)
	/  :Vector-Scalar Division (V):(V),(V),(I,F)
	/  : Matrix-Matrix Division (M):(M),(I,F)
	%  : Modulus (I):(I),(I)
	<  : Less than (B):(I,F),(I,F)
	<= : less than or equal (B):(I,F),(I,F)
	>  : Greater than (B):(I,F),(I,F)
	>= : Greater than or equal (B):(I,F),(I,F)
	== : Equal (B):(I,F),(I,F)
	!= : Not Equal (B):(I,F),(I,F)
	!  : Not (B):(B)
	|| : Or (B):(B),(B)
	&& : Or (B):(B),(B)



BINDING FUNCTIONS:
In order to make XPINS useful, you must implement the Function Binding code:
-Include your header files as necessary
-Declare custom parameters for the script
-Implement Custom Functions
-Write the actual Binding Code

In order to interact with your code, you must subclass XPINSBindings. For your convenience XPINSLocalBindings is provided, but if you plan to run different scripts in the same program it is reccommended that each script have its own binding class. When you implement XPINSLocalBindings be sure to include any header files necessary, whether it is for parameter passing or for function implementation. Make sure that XPINSBindings.h is included in the header file for your subclass.

Through your subclass of XPINSBindings you can pass values to your script. For example, if you are using XPINS to script your game AI, you might have a reference to a particular character as one of the members of your subclass.
When you are ready to execute a script, remember to give these references to your Bindings object. In order to access these values, you will need to use your bindings functions.

Once you have declared the data members for your bindings object, you must declare the scriptable functions. It is up to you as to what you should name them, but it is reccomended that you give them the same name you gave them when they were declared your @FUNC block. It is also reccomended that these functions are private functions.

If you want to write a function that takes a VEC or MAT variable as a parameter, it will be passed as an object of type XPINSScriptableMath::Vector or XPINSScriptableMath::Matrix, respectively. BOOL, INT, and FLOAT will be passed as their C/C++ cousins. For *___ (generic pointer type), you must write the function to receive a void* pointer. You can then extract the desired value:
MyType *var=(MyType*)arg1;
If your function returns a custom type, it must be returned as a void* pointer. By default XPINS will not memory manage this for you and you must free the object later to avoid a leak. If you want XPINS to memory manage this for you (i.e. delete it when the script is done executing), add the following line of code (My var is the pointer to the object):
this->toDelete.push_back(myVar);


In order know when to call your scripted functions, you must override BindFunction. In XPINSLocalBindings it looks like this:
void XPINSLocalBindings::BindFunction(int fNum,string script,XPINSParser::XPINSVarSpace* data,int& i,void* returnVal){
	switch(fNum){
		...
	}
}
Notic the switch statement.  For each function you declare, you need a case statement. It should look like this:
case __:{...}break;
the __ should be the assigned number for your function. To determine this number, look in your @FUNC block for your script, and count the number of function you declared before it and add one. If your block looks like this:
@FUNC
	VOID myVoidFunc();
	INT myIntFunc();
	MAT myMatrixFunc();
@END
myVoidFunc will be 1, myIntFunc will be 2, and myMatrixFunc will be 3.
Function 0 is reserved and may be useful in a future version of XPINS.
You will replace the '...' with the code to find your arguments and call your functions.

Once you have determined which function was called you need to figure out what values were passed to it. Good News: The parser does all of the heavy lifting. Here is what your code looks like:
___ arg__=parse___Arg(script,data,i,___);
Only four blanks. The first blank is the type of the argument. This should be one of the following, depending on what your function takes for the argument: bool, int, float, XPINSScriptableMath::Vector, XPINSScriptableMath::Matrix, or void*
The second blank should be the number of the argument, so the variable is called arg1, arg2, etc. (It is Your choice on whether or not to zero-index, just be consistent. In this documentation I will not be zero-indexing).
The third blank should match the type: Bool, Int, Float, Vec, Mat, or Pointer.
The final blank is the expected end character. This is ',' unless it is the final argument for a function, in which case it is ')'.
So for a VEC argument that is the 2nd but not last argument in a function, the code would look like this:
XPINSScriptableMath::Vector arg2=parseVecArg(script,parameters,vars,index,',');
For functions that don't take arguments, simply use this line of code:
while(scriptText[++i]!=')');

Finally, the most important part: calling your functions. This actually is only one line of code (per function), and it goes right after the code for Finding the arguments:
*returnVal=f__(...);
-the first blank is the number for the function (e.g. if it is the first function declared, then f1)
-the "..." is the arguments for the functions (the arg_ variables you created earlier):
So if I have function F11 that takes two arguments and returns a bool:
*returnVal=f11(arg1,arg2);

NOTE: For help with Function Binding, look at the Built In Function implementaitons in XPINSBuiltIn.cpp. Built in Functions are processed almost the same way that your functions are bridged (however many of those function calls are replaced with operators).


COMPILING SCRIPTS
The first thing you need to do to run a script is compile the Script so that the parser can interpret the variables and functions correctly.

The following Script:
@COMPILER[0.4]
@PARSER[0.9]
@FUNC
	INT MAGIC_NUMBER(FLOAT,BOOL);
	*MYPLAYER AI_PLAYER_FUNC();
@END
@CODE
	INT $MYVAR2=#MAGIC_NUMBER(^0.2,^T);
	@WHILE[X_LESS($MYVAR2,^90)]
	{
		$MYVAR2=X_ADD($MYVAR2,^10);
	}
	*MYPLAYER $AIPLAYER=#AI_PLAYER_FUNC();
	#SET_FIRE_ANGLE($AIPLAYER,$MYVAR2);
@END

Would look like this once compiled:
@PARSER[0.9]
@VAR B1 I1 F0 V0 M0 P1
@CODE
$I0=#IF1(^0.2,^T);
@WHILE[XB3($I0,^90)]
{
$I0=XF0($I0,^10);
}
$P0=#PF2();
#F3($P0,$I0);
@END

There are two options for compiling:
	-Build and Run the compiler on one of your machines. You will need to distribute the compiled script (usually with your program, sometimes via your server).
	-Distribute your uncompiled script and compile it at runtime.
The first option is usually a better option if your program is running on a system with constrained resources (e.g. smartphones). It will also reduce your program size as (A) you do not have do include the code for the compiler and (B) compiled scripts tend to be smaller than uncompiled scripts. 
However, the second option has a few important use cases. First, if you want to make the scripts user-modifiable, you need to compile them at runtime. Editing compiled scripts by hand is strongly discouraged and could cause your program to crash. Second, if your program is open source, you should consider distributing the script in its uncompiled from.


To compile on your machine: Compile the compiler and run it on your machine. Making sure that the script file has the extension .XPINS, enter in the full path for your script. The compiler will write the compiled script to a file with the extension .XPINSX. If it doesn't write a file but displays a compiled script, copy that into a .XPINSX file. Ship the .XPINSX file with your program, and load it into a string object at runtime.
To compile at runtime: Include XPINSCompiler.h in whatever file you wish to use XPINS with (make sure to adjust your build settings so that the compiler and parser are compiled as part of your program) Ship the uncompiled XPINS file with your program, and Load it in at runtime to a string object. then add the following code:
	if(!XPINSCompiler::compileScript(&myScript)){
		//script did not compile, work without script or exit.
	}
	The compiler will write to the same object that you passed to it instead of creating a new string object

RUNNING SCRIPTS
To run the script, inlcude XPINSParser.h and the header file for your bindings subclass, and add the following code:
string myScript="...";//Make sure you have your script loaded into memory
XPINSLocalBindings *myBindings=new XPINSLocalBindings();//replace with your subclass
//Set up bindings object
XPINSParser::ParseScript(myScript, myBindings);

Have Fun with XPINS!